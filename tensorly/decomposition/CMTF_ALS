import tensorly as tl
import tensorly.tenalg
import tensorly.random
import numpy as np


def rescale_to_unit_frobenius(matrix):
    # rescale every column of matrix
    return matrix / tl.norm(matrix, axis=0)


def solve_ls(A, B):
    # solve ||B-AX||^2 (AX = B -> X = A^{-1} @ B)
    X = tl.pinv(A) @ B
    return X


def calculate_f(X, Y, A, B, C, V):
    # calculate value of f in cmtf
    return 1 / 2 * tl.norm(X - tl.kruskal_tensor.kruskal_to_tensor((None, [A, B, C]))) ** 2 + 1 / 2 * tl.norm(
        Y - A @ V.T)


def factor_match_score_3d(A, B, C, V, A_hat, B_hat, C_hat, V_hat):
    """ Calculates factor match score (FMS) for comparing true and estimated matrices.

    Assume 3rd order tensor X and matrix Y are coupled in the 1th mode with
    X = [[A, B, C]] and Y = A @ V.T
    The FMS shows how close the estimation of A, B, C, V is to the true matrices.
    An FMS of 1 is a perfect match. The worst value is 0.

    Formula for FMS according to Equation 4
    @article{acar2011all,
      title={All-at-once optimization for coupled matrix and tensor factorizations},
      author={Acar, Evrim and Kolda, Tamara G and Dunlavy, Daniel M},
      journal={arXiv preprint arXiv:1105.3422},
      year={2011}
    }

    Parameters
    ----------
    A : tl.tensor
        true 1st factor matrix of tensor X
    B : tl.tensor
        true 2nd factor matrix of tensor X
    C : tl.tensor
        true 3rd factor matrix of tensor X
    V : tl.tensor
        true matrix for generating Y
    A_hat : tl.tensor
        estimated 1st factor matrix of tensor X
    B_hat : tl.tensor
        estimated 2nd factor matrix of tensor X
    C_hat : tl.tensor
        estimated 3rd factor matrix of tensor X
    V_hat : tl.tensor
        estimated matrix for generating Y

    Returns
    -------
    factor match score : float
        value between 0 and 1 that shows how good the estimation is, 1 is perfect

    """

    R = A.shape[1]

    # calculate weights
    lambda_ = tl.zeros(R)
    lambda_hat = tl.zeros(R)
    alpha_ = tl.zeros(R)
    alpha_hat = tl.zeros(R)
    xi = tl.zeros(R)
    xi_hat = tl.zeros(R)
    for r in range(R):
        lambda_[r] = tl.norm(A[:, r]) * tl.norm(B[:, r]) * tl.norm(C[:, r])
        lambda_hat[r] = tl.norm(A_hat[:, r]) * tl.norm(B_hat[:, r]) * tl.norm(C_hat[:, r])
        alpha_[r] = tl.norm(A[:, r]) * tl.norm(V[:, r])
        alpha_hat[r] = tl.norm(A_hat[:, r]) * tl.norm(V_hat[:, r])
        xi[r] = lambda_[r] + alpha_[r]
        xi_hat[r] = lambda_hat[r] + alpha_hat[r]

    # take care of permutation of normalized matrices (not mentioned in paper, but necessary)
    perm = (A.T @ A_hat) * (B.T @ B_hat) * (C.T @ C_hat) / (lambda_[:, None] @ lambda_hat[None, :])
    order = tl.argmax(perm, axis=1)
    perm = perm[:, order]  # perm[r,r] now corresponds to \prod_i (a^i_r.T @ ahat^i_r) / (||(a^i_r|| ||ahat^i_r||)
    V_hat = V_hat[:, order]
    xi_hat = xi_hat[order]

    # calculate factor match score
    FMS = tl.zeros(R)
    for r in range(R):
        FMS[r] = (1 - tl.abs(xi[r] - xi_hat[r]) / tl.max([xi[r], xi_hat[r]])) * tl.abs(
            perm[r, r] * tl.dot(V[:, r], V_hat[:, r])) / (tl.norm(V[:, r]) * tl.norm(V_hat[:, r]))
    return tl.min(FMS)


def cmtf_als_for_third_order_tensor(X, Y, R):
    """
    Calculates a coupled matrix and tensor factorization of 3rd order tensor and matrix which are coupled in first mode.

    Assume you have 3rd order tensor X = [[A,B,C]] and matrix Y = A @ V.T, which are coupled in 1st mode.
    With coupled matrix and tensor factorization (CTMF), the factor matrices A, B, C for the CP decomposition of X
    and the matrix V are found.
    This implementation only works for a coupling in the first mode.

    Solution is found via alternating least squares (ALS) as described in Figure 5 of
    @article{acar2011all,
      title={All-at-once optimization for coupled matrix and tensor factorizations},
      author={Acar, Evrim and Kolda, Tamara G and Dunlavy, Daniel M},
      journal={arXiv preprint arXiv:1105.3422},
      year={2011}
    }

    Parameters
    ----------
    X : tl.tensor
        3rd order tensor with factor matrices [[A, B, C]]
    Y : tl.tensor
        matrix that is coupled with tensor in first mode: Y = A @ V.T
    R : int
        rank for CP decomposition of X

    Returns
    -------
    A, B, C, V : estimated matrices

    Examples
    --------
    A = tl.tensor([[1, 2], [3, 4]])
    B = tl.tensor([[1, 0], [0, 2]])
    C = tl.tensor([[2, 0], [0, 1]])
    V = tl.tensor([[2, 0], [0, 1]])
    R = 2

    X = tl.kruskal_to_tensor([None, [A, B, C]])  # weights are None
    Y = A @ V.T

    A_hat, B_hat, C_hat, V_hat = cmtf_als_for_third_order_tensor(X, Y, R)

    """

    # initialize values
    shape_list = X.shape
    s = shape_list + (Y.shape[1],)
    A, B, C, V = tl.random.random_kruskal(s, R).factors
    f_old = np.inf

    # alternating least squares
    # note that no rescaling is done since it is not guaranteed that the columns in true matrices have unit norm
    # note that the order of the khatri rao product is reversed since tl.unfold has another order than assumed in paper
    for iteration in range(10 ** 4):
        A = solve_ls(tl.concatenate((tl.tenalg.khatri_rao([B, C]).T, V.T), axis=1).T,
                     tl.concatenate((tl.unfold(X, 0), Y), axis=1).T).T
        B = solve_ls(tl.tenalg.khatri_rao([A, C]), tl.unfold(X, 1).T).T
        C = solve_ls(tl.tenalg.khatri_rao([A, B]), tl.unfold(X, 2).T).T
        V = solve_ls(A, Y).T
        f_new = calculate_f(X, Y, A, B, C, V)
        if tl.abs(f_new - f_old) / f_old <= 1e-8:
            # print(f'break after{iteration} iterations with f = {f_old}')
            break
        f_old = f_new

    return A, B, C, V

